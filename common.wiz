import "ram";
import "nes";
import "data";

#[fallthrough] func call_t0() {
    goto *(&t0 as *func);
}

func clear_nametable_vram() {
    a = nes.ppu.status;
    nes.ppu.address = a = >:nes.ppu.ADDRESS_NAMETABLE_DATA;
    nes.ppu.address = a = <:nes.ppu.ADDRESS_NAMETABLE_DATA;
    a = 0;

    for y in 8 .. 1 by -1 {
        for x in 0 .. 255 {
            nes.ppu.data = a;
        }
    }
}

//NAMETABLE_A | (((y) << 5) | (x))
//NTADR_A(tmp3, tmp2)


func load_tilemap() {
    let START_X = 0;
    let START_Y = 0;

    a = nes.ppu.status;
    var tile @ &t0 : u8;
    var row @ &t1 : u8;
    var tile_high @ &t2 : u8;
    var tile_low @ &t3 : u8;
    var tile_address @ &t4 : u16;

    row = a = 0;
    tile_low = a = 0;
    tile_high = a = 0;
    for x in 0 .. 239{
        if { a = x & 15; } && zero
        {
            if x != 0
            {
                ++row;
            }
        }
        if { a = row - 4; } && zero
        {
            row = a = 0;
            tile_low = a = 0;
            ++tile_high;
        }
        tile = a = row << 5;    
        b1 = a = tile_low << 1;
        tile = a = tile + b1;

        <:tile_address = a = <:nes.ppu.ADDRESS_NAMETABLE_DATA + tile;
        >:tile_address = a = >:nes.ppu.ADDRESS_NAMETABLE_DATA + tile_high;
        
        nes.ppu.address = a = >:tile_address;
        nes.ppu.address = a = <:tile_address;

        b0 = a = data.level1[x];
        y = a = b0 << 2; // each metatile is 4 pieces
        b1 = a = data.ts1[y];
        nes.ppu.data = a = b1;
        y++;
        b1 = a = data.ts1[y];
        nes.ppu.data = a = b1;
        y++;

        tile = a = tile + 32;
        // <:tile_address = a = <:nes.ppu.ADDRESS_NAMETABLE_DATA + tile;
        >:tile_address = a = >:nes.ppu.ADDRESS_NAMETABLE_DATA + tile_high;
        nes.ppu.address = a = >:tile_address;
        // nes.ppu.address = a = <:tile_address;

        // b0 = a = data.level1[x];
        // y = a = b0 << 2; // each metatile is 4 pieces
        // b1 = a = data.ts1[y];
        // nes.ppu.data = a = b1;
        // y++;
        // b1 = a = data.ts1[y];
        // nes.ppu.data = a = b1;
        // y++;

        ++tile_low;
    }
}

func load_palette() {
    a = nes.ppu.status;
    nes.ppu.address = a = >:nes.ppu.ADDRESS_PALETTE_DATA;
    nes.ppu.address = a = <:nes.ppu.ADDRESS_PALETTE_DATA;

    for x in 0 .. (nes.ppu.PALETTE_SIZE * nes.ppu.PALETTE_COUNT) - 1 {
        nes.ppu.data = a = data.palette[x];
    }
}

func print_text() {
    let START_X = 10;
    let START_Y = 3;
    let TILE_ADDRESS = nes.ppu.ADDRESS_NAMETABLE_DATA + START_Y * 32 + START_X;
    
    // Read PPU status to reset its state.
    a = nes.ppu.status;
    // Now setup the PPU for copying tiles.
    nes.ppu.address = a = >:TILE_ADDRESS;
    nes.ppu.address = a = <:TILE_ADDRESS;
    
    x = 0;

    while { a = data.message[x]; } && !zero {
        x++;
        nes.ppu.data = a;
    }
}